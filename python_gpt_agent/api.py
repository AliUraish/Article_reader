#!/usr/bin/env python3
"""
FastAPI Backend for Article Summarization
Supports both OpenAI GPT and Google Gemini models.
"""

import os
from typing import Literal
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, HttpUrl
import google.generativeai as genai
from openai import OpenAI

# Load environment variables from .env file
load_dotenv()

# AgentBasis SDK for observability and tracing
import agentbasis
from agentbasis.llms.openai import instrument as instrument_openai
from agentbasis.llms.gemini import instrument as instrument_gemini

# Initialize AgentBasis SDK (reads from AGENTBASIS_API_KEY and AGENTBASIS_AGENT_ID env vars)
agentbasis.init()

# Instrument both LLM providers - all calls will now be tracked
instrument_openai()
instrument_gemini()

# Import extraction functions from main.py
from main import extract_content, summarize_text

# Initialize FastAPI app
app = FastAPI(title="Article Summarization API")

# Configure CORS for frontend (comma-separated origins in CORS_ORIGINS)
cors_origins_env = os.getenv("CORS_ORIGINS", "http://localhost:5173,http://localhost:3000")
cors_origins = [origin.strip() for origin in cors_origins_env.split(",") if origin.strip()]

app.add_middleware(
    CORSMiddleware,
    allow_origins=cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Request/Response Models
class ExtractRequest(BaseModel):
    url: HttpUrl

class ExtractResponse(BaseModel):
    title: str
    content: str

class SummarizeRequest(BaseModel):
    title: str
    content: str
    format: Literal["BULLET_POINTS", "PARAGRAPH"]
    maxWords: int
    model: Literal["gpt", "gemini"]

class SummarizeResponse(BaseModel):
    summary: str

# Initialize Gemini
def init_gemini():
    """Initialize Gemini API with API key from environment."""
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise ValueError("GEMINI_API_KEY environment variable is not set")
    genai.configure(api_key=api_key)

def summarize_with_gemini(title: str, text: str, format_type: str, max_words: int) -> str:
    """
    Summarize text using Google Gemini.
    
    Args:
        title: Article title
        text: Article content
        format_type: 'BULLET_POINTS' or 'PARAGRAPH'
        max_words: Maximum words in summary
        
    Returns:
        Summary text
    """
    init_gemini()
    
    format_instruction = (
        "Return the summary as a concise list of bullet points."
        if format_type == "BULLET_POINTS"
        else "Return the summary as a cohesive paragraph."
    )
    
    prompt = f"""
    Please summarize the following article titled "{title}".
    
    Article Content:
    {text[:15000]}

    Requirements:
    1. {format_instruction}
    2. The summary must be approximately {max_words} words or less.
    3. Capture the main arguments, key findings, and essential context.
    4. Focus only on the core message.
    """
    
    try:
        model = genai.GenerativeModel('gemini-2.5-flash')
        response = model.generate_content(
            prompt,
            generation_config=genai.GenerationConfig(
                temperature=0.7,
                top_p=0.95,
                top_k=40,
            )
        )
        
        if not response.text:
            raise Exception("No summary generated by Gemini")
        
        return response.text
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Gemini API error: {str(e)}")

@app.get("/")
async def root():
    """Health check endpoint."""
    return {"status": "ok", "message": "Article Summarization API"}

@app.post("/api/extract", response_model=ExtractResponse)
async def extract_article(request: ExtractRequest):
    """
    Extract article content from URL.
    
    Args:
        request: ExtractRequest with URL
        
    Returns:
        ExtractResponse with title and content
    """
    try:
        url_str = str(request.url)
        content = extract_content(url_str)
        
        # Try to extract title using trafilatura
        import trafilatura
        downloaded = trafilatura.fetch_url(url_str)
        title = "Untitled Article"
        
        if downloaded:
            metadata = trafilatura.extract_metadata(downloaded)
            if metadata and hasattr(metadata, 'title') and metadata.title:
                title = metadata.title
        
        return ExtractResponse(title=title, content=content)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Extraction failed: {str(e)}")

@app.post("/api/summarize", response_model=SummarizeResponse)
async def summarize_article(request: SummarizeRequest):
    """
    Summarize article content using selected model.
    
    Args:
        request: SummarizeRequest with content, format, and model selection
        
    Returns:
        SummarizeResponse with summary text
    """
    try:
        # Convert format to the style expected by summarize_text
        style = "points" if request.format == "BULLET_POINTS" else "para"
        
        if request.model == "gpt":
            # Use existing GPT summarization
            summary = summarize_text(
                request.content,
                style,
                "gpt-4o-mini",
                request.maxWords,
                use_tools=False  # Disable tools for API usage
            )
        elif request.model == "gemini":
            # Use Gemini summarization
            summary = summarize_with_gemini(
                request.title,
                request.content,
                request.format,
                request.maxWords
            )
        else:
            raise HTTPException(status_code=400, detail="Invalid model selection")
        
        # Flush AgentBasis data before returning (important for serverless)
        agentbasis.flush()
        
        return SummarizeResponse(summary=summary)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Summarization failed: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)
